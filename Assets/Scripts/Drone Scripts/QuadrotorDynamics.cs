namespace ISAACS
{
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using UnityEngine;

	public static class QuadrotorDynamics
	{

		// The acceleration due to gravity on the Earth's surface.
		private static Vector3 g = new Vector3(0.0f, -9.81f, 0.0f);

		/*
				f1
				O-->
			  /   \
		  f4 O-->  O--> f2
			  \   /
				O-->
				f3

		x-axis: f2 to f4
		y-axis: out of the page
		z-axis: f1 to f3
		*/

		/// <summary>
        /// Given the individual thrust of each rotor ("rotor forces"), this method computes the quadrotor's total thrust and torques.
		/// For simplicity, only the sign and magnitude of each rotor force is required, and only the sign and magnitude of the total thrust and torques is returned.
        /// </summary>
        /// <param name="rotorForces">The signed magnitude of the force exterted by each rotor, in the order shown in the diagram above.</param>
        /// <param name="rodLength">(Optional) The distance between two opposing rotors, such as O(f1) and O(f3). It is assumed that O(f1)->O(f3) and O(f2)->O(f4) are equal. Defaults to `1.0f`.</param>
        /// <param name="dragFactor">(Optional) A damping factor for the thrust, representing resistance by the drag. Defaults to `1.0f`.</param>
        /// <param name="thrustFactor">(Optional) The contribution of each rotor force to the total thrust, as well as its x-torque ("roll force") and z-torque ("pitch force"). Defaults to `1.0f`.</param>
        /// <param name="yawFactor">(Optional) The contribution of each rotor force to the y-torque ("yaw force"). Defaults to `1.0f`.</param>
        /// <returns>The signed mangitudes of the quadrotor's total thrust and torques, for the given rotor forces.</returns>
		public static Vector4 SpinRotors(Vector4 rotorForces, float rodLength=1.0f, float dragFactor=1.0f, float thrustFactor=1.0f, float yawFactor=1.0f)
		{
			float f1 = rotorForces.w;
			float f2 = rotorForces.x;
			float f3 = rotorForces.y;
			float f4 = rotorForces.z;

			Vector4 torques;
			torques.w = dragFactor * thrustFactor * (f1 + f2 + f3 + f4); // Thrust from all four rotors, accelerating the quadrotor in the direction of its y-axis.
			torques.x = rodLength  * thrustFactor * (f3 - f1);           // Torque rotating the quadrotor around its x-axis ("roll force").
			torques.y = yawFactor  * (f2 + f4 - f1 - f3);                // Torque rotating the quadrotor around its y-axis ("yaw force").
			torques.z = rodLength  * thrustFactor * (f4 - f2);           // Torque rotating the quadrotor around its z-axis ("pitch force").

			return torques;
		}			




		/// <summary>
        /// Given the quadrotor's thrust and mass, this method computes its acceleration in the inertial frame.
		/// Since Unity transforms refer to the inertial frame, the result can be directly integrated to solve for velocity and position.
        /// </summary>
        /// <param name="normal">The normal vector to the plane defined by the quadrotor's rods (ie. its y-axis).</param>
        /// <param name="thrust">The signed magnitude of the total thrust generated by the rotors.</param>
        /// <param name="mass">The total mass of the quadrotor.</param>
        /// <param name="gravitationalAcceleration">(Optional) The acceleration due to gravity. Defaults to (0, -9.81, 0), as on the Earth's surface.</param>
        /// <returns>The acceleration of the quadrotor in the inertial frame.</returns>
		public static Vector3 Acceleration(Vector3 normal, float thrust, float mass, Vector3 gravitationalAcceleration)
		{
			// If the direction vector is not a unit vector, normalize it.	
			if (!Vector3.Equals(normal, normal.normalized))
			{
				normal = normal.normalized;
			}

			// From Newton's law (F = ma), the acceleration of an object from an external force is equal to the force divided by the object's mass (a = F/m).
			float thrustAccelerationMagnitude = thrust / mass;
			// Scale the direction of the thrust acceleration by its magnitude, and sum it up with the gravitational acceleration.
			Vector3 acceleration = gravitationalAcceleration + thrustAccelerationMagnitude * normal;

			return acceleration;
		}




		/// <summary>
        /// Given the quadrotor's thrust and mass, this method computes its acceleration in the inertial frame.
		/// Since Unity transforms refer to the inertial frame, the result can be directly integrated to solve for velocity and position.
        /// </summary>
        /// <param name="normal">The normal vector to the plane defined by the quadrotor's rods (ie. its y-axis).</param>
        /// <param name="thrust">The signed magnitude of the total thrust generated by the rotors.</param>
        /// <param name="mass">The total mass of the quadrotor.</param>
        /// <param name="gravitationalAcceleration">(Optional) The acceleration due to gravity. Defaults to (0, -9.81, 0), as on the Earth's surface.</param>
        /// <returns>The acceleration of the quadrotor in the inertial frame.</returns>
		public static Vector3 Acceleration(Vector3 normal, float thrust, float mass)
		{
			// If the direction vector is not a unit vector, normalize it.	
			if (!Vector3.Equals(normal, normal.normalized))
			{
				normal = normal.normalized;
			}

			// From Newton's law (F = ma), the acceleration of an object from an external force is equal to the force divided by the object's mass (a = F/m).
			float thrustAccelerationMagnitude = thrust / mass;
			// Scale the direction of the thrust acceleration by its magnitude, and sum it up with the gravitational acceleration.
			Vector3 acceleration = g + thrustAccelerationMagnitude * normal;

			return acceleration;
		}




        /// Given the quadrotor's torques and moments of inertia, this method computes its angular acceleration in the inertial frame.
		/// For simplicity, it is assumed that the coriolis effect is negligible; hence, the result is the element-wise division of the torques by the inertia.
        /// </summary>
        /// <param name="wind">A vector representing the direction and magnitude of acceleration due to wind.</param>
        /// <param name="normal">The normal vector to the plane defined by the quadrotor's rods (ie. its y-axis).</param>
        /// <param name="mass">The total mass of the quadrotor.</param>
        /// <returns>The wind disturbance to be added to the linear acceleration in the inertial frame.</returns>documentation
		public static Vector3 WindDisturbance(Vector3 wind, Vector3 normal, float mass)
		{
			float angle = Vector3.Angle(wind, normal);
			return Mathf.Abs(Mathf.Cos(angle)) * wind / mass;
		}

	


		/// <summary>
        /// Given the quadrotor's torques and moments of inertia, this method computes its angular acceleration in the inertial frame.
		/// For simplicity, it is assumed that the coriolis effect is negligible; hence, the result is the element-wise division of the torques by the inertia.
        /// </summary>
        /// <param name="torques">The torques acting on the quadrotor, around its x, y, and z axes.</param>
        /// <param name="inertia">The non-zero moments of inertia of the quadrotor, commonly referred to as Ixx, Iyy, and Izz.</param>
        /// <returns>The angular acceleration of the quadrotor in the inertial frame.</returns>
		public static Vector3 AngularAcceleration(Vector3 torques, Vector3 inertia)
		{
			Vector3 inverseInertia;
			inverseInertia.x = 1.0f / inertia.x;
			inverseInertia.y = 1.0f / inertia.y;
			inverseInertia.z = 1.0f / inertia.z;
			return Vector3.Scale(torques, inverseInertia);
		}




		/// <summary>
        /// Given the quadrotor's torques and moments of inertia, this method computes its angular acceleration in the inertial frame.
		/// For simplicity, it is assumed that the coriolis effect is negligible; hence, the result is the element-wise division of the torques by the inertia.
        /// </summary>
        /// <param name="thrustForces">A vector holding the thrust (.w) and torques (.x, .y, .z) acting on the quadrotor.</param>
        /// <param name="inertia">The non-zero moments of inertia of the quadrotor, commonly referred to as Ixx, Iyy, and Izz.</param>
        /// <returns>The angular acceleration of the quadrotor in the inertial frame.</returns>
		public static Vector3 AngularAcceleration(Vector4 thrustForces, Vector3 inertia)
		{
			Vector3 torques;
			torques.x = thrustForces.x;
			torques.y = thrustForces.y;
			torques.z = thrustForces.z;

			Vector3 inverseInertia;
			inverseInertia.x = 1.0f / inertia.x;
			inverseInertia.y = 1.0f / inertia.y;
			inverseInertia.z = 1.0f / inertia.z;

			return Vector3.Scale(torques, inverseInertia);
		}




		/// <summary>
        /// This method inverts the dynamics equations, to solve for the rotor forces that will accelerate the quadrotor towards its destination, keeping its speed as close to the target speed as possible.
        /// </summary>
        /// <param name="normal">The normal vector to the plane defined by the quadrotor's rods (ie. its y-axis).</param>
        /// <param name="destination">The destination of the quadrotor (for example, the coordinates of the next waypoint).</param>
        /// <param name="position">The current position of the quadrotor.</param>
        /// <param name="targetSpeed">The target speed to maintain throughout the flight.</param>
        /// <param name="velocity">The current velocity of the quadrotor.</param>
        /// <param name="angularVelocity">The current angular velocity of the quadrotor.</param>
        /// <param name="inertia">The non-zero moments of inertia of the quadrotor, commonly referred to as Ixx, Iyy, and Izz.</param>
        /// <param name="mass">The total mass of the quadrotor.</param>
        /// <param name="gravitationalAcceleration">(Optional) The acceleration due to gravity. Defaults to (0, -9.81, 0), as on the Earth's surface.</param>
        /// <param name="rodLength">(Optional) The distance between two opposing rotors, such as O(f1) and O(f3). It is assumed that O(f1)->O(f3) and O(f2)->O(f4) are equal. Defaults to `1.0f`.</param>
        /// <param name="dragFactor">(Optional) A damping factor for the thrust, representing resistance by the drag. Defaults to `1.0f`.</param>
        /// <param name="thrustFactor">(Optional) The contribution of each rotor force to the total thrust, as well as its x-torque ("roll force") and z-torque ("pitch force"). Defaults to `1.0f`.</param>
        /// <param name="yawFactor">(Optional) The contribution of each rotor force to the y-torque ("yaw force"). Defaults to `1.0f`.</param>
        /// <param name="degrees">(Optional) Whether the angular velocity and angular acceleration are in degrees, or radians. Default to `true` (degrees).</param>
        /// <returns>An estimate (using Euler's method) for the rotor forces that will move the quadrotor closer to its destination.</returns>
		public static Vector4 TargetRotorForces(
												Vector3 normal,
												Vector3 destination,
												Vector3 position,
												float targetSpeed,
												Vector3 velocity,
												Vector3 angularVelocity,
												Vector3 inertia,
												float mass,
												Vector3 gravitationalAcceleration,
												float decelerationDistance=-1.0f,
												float rodLength=1.0f,
												float dragFactor=1.0f,
												float thrustFactor=1.0f,
												float yawFactor=1.0f,
												bool degrees=true
												)
		{
			// Check if a distance from which the quadrotor must start decelerating was given.
			if (decelerationDistance > 0.0f)
			{
				float distanceLeft = (destination - position).magnitude;

				// Adjust the quadrotor's target speed, but only do so if more than 10% of the deceleration distance was traversed.
				// Otherwise, the drone will take an immense amount of time to reach its destination because its speed will be too small.
				if (distanceLeft < decelerationDistance && distanceLeft > 0.1f * decelerationDistance)
				{
					targetSpeed *= Mathf.Sqrt(distanceLeft / decelerationDistance);
				}	
			}

			// Compute the desired linear velocity.
			Vector3 targetVelocity = targetSpeed * (destination - position).normalized;

			// Compute the desired linear acceleration.
			Vector3 targetAcceleration = targetVelocity - velocity - gravitationalAcceleration;


			// Compute the desired angular velocity.
			Vector3 targetAngularVelocity = targetAngularVelocity = Quaternion.FromToRotation(normal, targetAcceleration).eulerAngles;

			// If the angular velocity and angular acceleration are in radians, convert the result to radians.
			if (!degrees)
			{
				targetAngularVelocity *= Mathf.PI / 180.0f;
			}

			// Compute the desired angular acceleration.
			Vector3 targetAngularAcceleration = targetAngularVelocity - angularVelocity;

			// The desired acceleration from thrust is the magnitude of the desired acceleration vector.
			float thrustAccelerationMagnitude = targetAcceleration.magnitude;

			// Compute the desired total thrust to be generated by the rotors, using Newton's Law (F = ma).
			float thrust = mass * thrustAccelerationMagnitude;

			// Compute the target torques to be generated by the torques, by inverting the equation of angular acceleration.
			Vector3 torques = Vector3.Scale(targetAngularAcceleration, inertia);

			// Compute the constants needed to solve for the rotor forces.
			float W = thrust / (dragFactor * thrustFactor);
			float X = torques.x / (rodLength * thrustFactor);
			float Y = torques.y / yawFactor;
			float Z = torques.z / (rodLength * thrustFactor);

			// Solve for the rotor forces.
			float f1 = (W - Y - 2.0f * X) / 4.0f;
			float f3 = X + f1;
			float f2 = (Y - Z + f1 + f3) / 2.0f;
			float f4 = Z + f2;

			Vector4 forces;
			forces.w = f1;
			forces.x = f2;
			forces.y = f3;
			forces.z = f4;

			return forces;
		}




		/// <summary>
        /// This method inverts the dynamics equations, to solve for the rotor forces that will accelerate the quadrotor towards its destination, keeping its speed as close to the target speed as possible.
        /// </summary>
        /// <param name="normal">The normal vector to the plane defined by the quadrotor's rods (ie. its y-axis).</param>
        /// <param name="destination">The destination of the quadrotor (for example, the coordinates of the next waypoint).</param>
        /// <param name="position">The current position of the quadrotor.</param>
        /// <param name="targetSpeed">The target speed to maintain throughout the flight.</param>
        /// <param name="velocity">The current velocity of the quadrotor.</param>
        /// <param name="angularVelocity">The current angular velocity of the quadrotor.</param>
        /// <param name="inertia">The non-zero moments of inertia of the quadrotor, commonly referred to as Ixx, Iyy, and Izz.</param>
        /// <param name="mass">The total mass of the quadrotor.</param>
        /// <param name="gravitationalAcceleration">(Optional) The acceleration due to gravity. Defaults to (0, -9.81, 0), as on the Earth's surface.</param>
        /// <param name="rodLength">(Optional) The distance between two opposing rotors, such as O(f1) and O(f3). It is assumed that O(f1)->O(f3) and O(f2)->O(f4) are equal. Defaults to `1.0f`.</param>
        /// <param name="dragFactor">(Optional) A damping factor for the thrust, representing resistance by the drag. Defaults to `1.0f`.</param>
        /// <param name="thrustFactor">(Optional) The contribution of each rotor force to the total thrust, as well as its x-torque ("roll force") and z-torque ("pitch force"). Defaults to `1.0f`.</param>
        /// <param name="yawFactor">(Optional) The contribution of each rotor force to the y-torque ("yaw force"). Defaults to `1.0f`.</param>
        /// <param name="degrees">(Optional) Whether the angular velocity and angular acceleration are in degrees, or radians. Default to `true` (degrees).</param>
        /// <returns>An estimate (using Euler's method) for the rotor forces that will move the quadrotor closer to its destination.</returns>
		public static Vector4 TargetRotorForces(
												Vector3 normal,
												Vector3 destination,
												Vector3 position,
												float targetSpeed,
												Vector3 velocity,
												Vector3 angularVelocity,
												Vector3 inertia,
												float mass,
												float decelerationDistance=-1.0f,
												float rodLength=1.0f,
												float dragFactor=1.0f,
												float thrustFactor=1.0f,
												float yawFactor=1.0f,
												bool degrees=true
												)
		{
			// Check if a distance from which the quadrotor must start decelerating was given.
			if (decelerationDistance > 0.0f)
			{
				float distanceLeft = (destination - position).magnitude;

				// Adjust the quadrotor's target speed, but only do so if more than 10% of the deceleration distance was traversed.
				// Otherwise, the drone will take an immense amount of time to reach its destination because its speed will be too small.
				if (distanceLeft < decelerationDistance && distanceLeft > 0.1f * decelerationDistance)
				{
					targetSpeed *= Mathf.Sqrt(distanceLeft / decelerationDistance);
				}	
			}

			// Compute the desired linear velocity.
			Vector3 targetVelocity = targetSpeed * (destination - position).normalized;

			// Compute the desired linear acceleration.
			Vector3 targetAcceleration = targetVelocity - velocity - g;

			// Compute the desired angular velocity.
			Vector3 targetAngularVelocity = Quaternion.FromToRotation(normal, targetAcceleration).eulerAngles;

			// If the angular velocity and angular acceleration are in radians, convert the result to radians.
			if (!degrees)	
			{
				targetAngularVelocity *= Mathf.PI / 180.0f;
			}	

			// Compute the desired angular acceleration.
			Vector3 targetAngularAcceleration = targetAngularVelocity - angularVelocity;

			// The desired acceleration from thrust is the magnitude of the desired acceleration vector.
			float thrustAccelerationMagnitude = targetAcceleration.magnitude;

			// Compute the desired total thrust to be generated by the rotors, using Newton's Law (F = ma).
			float thrust = mass * thrustAccelerationMagnitude;

			// Compute the target torques to be generated by the torques, by inverting the equation of angular acceleration.
			Vector3 torques = Vector3.Scale(targetAngularAcceleration, inertia);

			// Compute the constants needed to solve for the rotor forces.
			float W = thrust / (dragFactor * thrustFactor);
			float X = torques.x / (rodLength * thrustFactor);
			float Y = torques.y / yawFactor;
			float Z = torques.z / (rodLength * thrustFactor);

			// Solve for the rotor forces.
			float f1 = (W - Y - 2.0f * X) / 4.0f;
			float f3 = X + f1;
			float f2 = (Y - Z + f1 + f3) / 2.0f;
			float f4 = Z + f2;

			Vector4 forces;
			forces.w = f1;
			forces.x = f2;
			forces.y = f3;
			forces.z = f4;

			return forces;
		}

	}
}